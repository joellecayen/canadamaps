---
title: "canadianmaps"
author: "Joelle Cayen"
date: "28/01/2022"
output: html_document
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, out.width="100%")

library(stringr)
library(ggplot2)
library(cowplot)
library(kableExtra)
library(tidyverse)
```

## Installing and loading the package

This package is publicly available to download on GitHub. To install and load you can run the following lines in the console:

```{r install}
#devtools::install_github("joellecayen/canadianmaps")
library(canadianmaps)
```

This package currently comes with three datasets:  
  
* PROV (provincial map file)  
* FSA (forward sortation area map file)  
* REG (regional map file)  
  
The `PROV` dataset has 13 rows, one for each province, and multiple columns with province/territory names as well as X and Y variables (these represent the centroid of each province shape, used for adding labels) and the geometry column. This is made up of nested lists which make up the complex geometry shapes for each province/territory.

```{r data}
PROV %>%
  mutate(geometry = paste0(substr(geometry, 1, 15), "..."))%>%
  relocate(PT, .after = PRUID) %>%
  head()%>%
  kbl() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```


## Overview of available functions

* `theme_map()`
* `geom_prov()`
* `greom_reg()`
* `geom_fsa()`
* `label_prov()`
* `label_reg()`
* `text_prov()`
* `scale_fill_map()`
* `scale_color_map()`
* `crs_coord()`
* `coord_transform()`


The `geom_prov()` function loads and maps the provincial dataset, this is to be used in combination with `ggplot2`. `crs_coord()` contains the crs string which is required for mapping (this is all done behind scenes so you wonâ€™t need to add anything in this function). The `theme_map()` function gives ggplot a blank canvas to map on. The `scale_fill_map()` and `scale_color_map()` functions have several custom colour paletes which can be used for mapping and filling/colouring qualitative data (works with other types of graphs in `ggplot2` as well).


## Color palettes

```{r, echo=FALSE, fig.height=3, out.width = "100%", fig.align="center"}

dat <- data.frame(x = c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l"), y=1)


palettes <- c("Bright", "Pastel", "Kelly", "Teal", "Beach", "Summer", "Mauve", "Anada", "Viv", "Jess", "Starbs", "Purples", "CNISP", "PHAC",  "HAI")

for (i in 1:length(palettes)) {
  
assign(str_glue("g_{i}"), ggplot() +
    geom_bar(aes(x=x, y=y, fill=x), data = dat, stat="identity") + # 5
    scale_fill_map(palettes[i], 12) +
    guides(fill = FALSE) +
    ggtitle(palettes[i])+
    theme_map() +
      theme(plot.margin=unit(c(0.5,0.25,0.25,0.25),"cm"),
            plot.title = element_text(size=12))
)
}


plot_grid(g_1, g_2, g_3, g_4, g_5, g_6, g_7, g_8, g_9, g_10, g_11, g_12, g_13, g_14, g_15,
          #labels = c("Bright", "Pastel", "Kelly", "CNISP", "PHAC", "Teal", "Beach", "Summer", "Mauve"),
          #label_size = 15,
          align="hv", ncol = 5) 


```


## Creating a simple provincial map

### Creating the base shape layer

```{r}
library(ggplot2)
library(canadianmaps)

mymap <- ggplot() +
          geom_prov() + # load and map provincial data (fill is automatically set to province)
          crs_coord() + # this is required for mapping (stores the coordinate system)
          scale_fill_map("Kelly", 13) + # choosing palette Kelly and assigning 13 colours (one for each province)
          guides(fill = "none") + # this removes the colour legend
          theme_map() # sets backgroud to blank canvas 

mymap

```


### Adding labels

```{r}
names(PROV)
# Decide which column you want as your labels. The default is "PT"
mymap_text <- mymap +
  text_prov() # decided to leave as the default 
  
mymap_text


mymap_label <- mymap +
  label_prov(label="PREABBR") # chose the column with the english abbreviations

mymap_label

```


## Adding your data to the shapefile

```{r, echo=FALSE}
library(dplyr)
library(scales)

prov <- c("BC","QC","NU","PE","SK","YT","MB","ON","NB","NT","AB","NL","NS")
values <- c(2, 4, 1, 3, 6, 0, 3, 8, 9, 2, 1, 0, 7)

data <- data.frame(prov, values)

data <- data %>%
  mutate(perc = percent(values/sum(values, na.rm=T), accuracy=1))

```

Here's an example dataset that we want to map. It has 13 rows (one for each province/territory) and has three variables: prov, values, and perc. 

```{r, echo=FALSE}
data
```


We're going to take our data and join it with the `PROV` dataset from the `canadianmaps` package.

```{r}
alldata <- PROV %>%
  left_join(data, by=c("PT" = "prov")) 

head(alldata)
```



Since this map is coloured based on quantitative values, I decided to use the `scale_fill_continuous_sequential()` function from the `colorspace` package.

```{r, out.width="100%", fig.height=4, fig.width=14, fig.align="center"}

library(colorspace)

```

```{r, out.width="100%"}

ggplot() +
  geom_prov(alldata, fill = "values") + #changed the dataset to alldata
  crs_coord() +
  label_prov(alldata, label="perc") + #changed the dataset to alldata
  scale_fill_continuous_sequential(palette = "SunsetDark", na.value="grey90") +
  guides(fill = "none") +
  theme_map()

```


## Transforming your location data

The function `coord_transform()` allows you to deal with the coordinate system, which includes both projection and extent of the map. By default, this function uses the same projection as the PROV and FSA maps (epsg:4269). This allows us to easily transform any data to match the base files and be compatible for layering. If you skip this step and try to map your points directly on the map you'll notice they all clump together at the bottom of the map.  
  
The `coord_transform()` function requires three pieces of information.
1. the name of the dataset
2. the name of the longitude variable in quotes
3. the name of the latitude variable in quotes


```{r}
library(maps)

cities <- canada.cities %>%
            filter(pop > 70000) %>%
  coord_transform("long", "lat") %>% # this is to tranform your points
  mutate(Colours = recode(capital, 
                         "0" = "Big city",
                         "1" = "National capital",
                         "2" = "Province capital" )) # created this variable for mapping in the next example

```

Once you've transformed your data using `coord_transform()` you can add it as a layer in your map using `geom_point()`. All you have to do is specify the name of the dataset and the x and y variables in the aesthetics. I've added a few extra parameters for size, color, transparancy, and shape. You can also use `geom_jitter()` to avoid overlapping points. You can specify the parameters for width and height to acheivean appropriate distance between points.

```{r, out.width="100%"}

ggplot() +
  geom_prov() + 
  crs_coord() + 
  geom_jitter(data=cities, aes(x=long, y=lat), size = 2, color = "black", alpha=0.5, shape = 18, position = position_jitter(width = 70000, height = 70000)) + # adding points
  label_prov() + 
  scale_fill_map("Kelly", 13) + 
  guides(fill = "none") + 
  theme_map()

```


If you want to colour your shapes based on another variable, you can do so by specifying colour in the aesthetics of `geom_point()` and adding `scale_color_manual()`. Here I decided to change the shape and colour based on the column Colours which has three values.

```{r, out.width="100%"}

ggplot() +
  geom_prov() + 
  crs_coord() + 
  geom_jitter(data=cities, aes(x=long, y=lat, alpha=Colours, color=Colours, shape=Colours, size = Colours), position = position_jitter(width = 60000, height = 60000)) +
  scale_alpha_manual(values = c(0.6, 1, 0.6))+
  scale_shape_manual(values=c(19, 18, 18))+
  scale_color_manual(values=c('#6E8B93', '#F24333', '#F24333'))+
  scale_size_manual(values=c(2, 6, 4))+
  label_prov() + 
  scale_fill_map("CNISP", 26, rev=T) + 
  guides(fill = "none") + 
  theme_map() +
  theme(legend.position = c(0.75, 0.6),
        legend.title = element_blank())

```


#### Mapping FSA data

The function `geom_fsa()` maps FSA data from stats can. The default is to colour based on each province, because colouring each FSA would be busy. Similar to before you can merge your own data based on FSA columns to the `FSA` dataset. For now let's just take a look at the default FSA map. 

```{r, out.width="100%"}

ggplot() +
  geom_fsa() + 
  crs_coord() + 
  scale_fill_map("Kelly", 13) + 
  guides(fill = FALSE) + 
  theme_map() 

```

Now let's add some labels. Using the `text_prov()` function we will add labels in the center of each province. Similar to before, you can merge your own data with the PROV dataset to achieve different labels. For now we'll start with adding the province codes which is the default.

```{r, out.width="100%"}

ggplot() +
  geom_fsa() + 
  crs_coord() + 
  text_prov() + # adding labels from the PROV dataset (default is two digit codes)
  scale_fill_map("Kelly", 13) + 
  guides(fill = "none") + 
  theme_map() 

```

#### Adding your own data

```{r, echo=FALSE, message=FALSE}

fsa <- c("J0K",	"K0K",	"L5M",	"L9T",	"K0A",	"L4N",	"L0R",	"V3S",	"V3W",	"S0K",	"L6R",	"L6Y",	"G0A",	"L6A",	"L5N",	"T0H",	"N0G",	"G0R",	"L6P",	"T3K",	"L7A",	"N0B",	"V0N",	"V4N",	"T3J",	"L4J",	"J0L",	"M2N",	"K0L",	"T3H",	"L4C",	"T5T",	"K2J",	"T2Z",	"L4H",	"G0S",	"T0M",	"L6X",	"V0R",	"M1B",	"V0E",	"T8N",	"L6M",	"N0M",	"T0B",	"S0G",	"L5B",	"J7V",	"T0C",	"J0B",	"L3R",	"J3Y",	"T2Y",	"T0L",	"L6H",	"T2A",	"G0L",	"T0A",	"T3G",	"G0X",	"M2J",	"V3R",	"T1Y",	"V3B",	"L3S",	"V2T",	"M9V",	"T0K",	"L4G",	"L0S",	"K1V",	"M1V",	"K4A",	"L4L",	"V0H",	"L6S",	"T3A",	"V0J",	"S0A",	"R0C",	"J0H",	"L4E",	"N0P",	"K0C",	"L1V",	"T6L",	"L6C",	"T6W",	"L5V",	"T0J",	"L3T",	"L1T",	"S0J",	"P0M",	"J0N",	"K0M",	"K2G",	"M5V",	"V3V",	"V2S")

data <- data.frame(fsa)

data <- data %>%
  mutate(val = row.names(.))
  
```

Using a mini dataset from stats can we can map the top 100 FSA's based on population. We do this by joining our datset `data` with the `FSA` dataset.

```{r, out.width="100%"}

# Top 25 FSA's with largest population
myFSA <- FSA %>%
left_join(data, by = c("CFSAUID" = "fsa")) %>%
  mutate(PT = case_when(!is.na(val) ~ PRNAME,
                        TRUE ~ NA_character_))

ggplot() +
  geom_fsa(myFSA, fill="PT", colour= "white", size = 0.7) + #remove lines by specifying colour = NA
  crs_coord() + 
  scale_fill_map("Viv", 7, na.value = "grey90") + 
  guides(fill = FALSE) + 
  theme_map() 

```




#### Mapping regional data

The third dataset in the `canadianmaps` package is a regional dataset. This file was made using the provincial shapefile, meaning there are still 13 shapes however they are grouped by region. Use `REG` if you wish only to show data by region. The functions `geom_reg()` and `label_reg()` are used to accomplish this.


```{r, out.width="70%", fig.align = "center"}

ggplot() +
  geom_reg() + 
  crs_coord() + 
  label_reg(size=6, colour = "black") +
  scale_fill_map("Starbs", 5, rev=T) + 
  guides(fill = FALSE) + 
  theme_map() 

```


## Graphing with the same colours

The functions `scale_fill_map()` and  `scale_color_map()` can also be used with other plot types in `ggplot2`.


```{r, out.width="100%"}

canada.cities %>%
  filter(country.etc != "Canada")%>%
  mutate(name = str_to_sentence(word(name)))%>%
  arrange(desc(pop))%>%
  slice_max(order_by = pop, n = 10)%>%
  mutate(label = str_glue("{round(pop/1000000, 1)} M"))%>%
  ggplot() +
    aes(x=reorder(name, desc(pop)), y = pop, fill=country.etc)+
    geom_col(alpha = 0.8)+
    geom_text(aes(label=label), vjust = 1.2, color = "white")+
    scale_fill_map("Bright", 5) +
  scale_y_continuous(labels = scales::comma)+
    theme_wallis() +
  ggtitle("Ten Largest Canadian Citites") +
    xlab("")+
    ylab("Population")+
    labs(fill = "")+
    theme(legend.position = c(0.7, 0.95),
          legend.direction = "horizontal",
          legend.background = element_rect(fill=NA),
          axis.text.x = element_text(angle = 70, hjust = 1.1))

```
